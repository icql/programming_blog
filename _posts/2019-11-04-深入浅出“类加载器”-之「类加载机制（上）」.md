---
layout:     post
title:      深入浅出“类加载器” 之「类加载机制（上）」
subtitle:   
date:       2019-11-4
author:     tomas家的小拨浪鼓
header-img: img/post-bg-20191014-article1.jpg
catalog: true
tags:
    - Java
    - JVM
---
# 深入浅出“类加载器” 之「类加载机制（上）」


> 本文主要是《深入探索 JVM》系列中『类加载器』系列文章，主要对“类的加载机制”做了详细的介绍。系列文章目录见：[《 深入探索 JVM 》文集](/programming_blog/2019/11/05/深入探索-JVM-文集/)

<br>

**『类加载器』篇文章推荐：**   
[深入浅出“类加载器” 之「类加载机制（上）」](/programming_blog/2019/11/04/深入浅出-类加载器-之-类加载机制-上/)  
深入浅出“类加载器” 之「类加载机制（下）」(待更新)  
深入浅出“类加载器” 之「线程上下文类加载器」(待更新)  
深入浅出“类加载器” 之「从 sun.misc.Launcher 类源码深入探索 ClassLoader」(待更新)  
深入浅出“类加载器” 之「案例分析：Tomcat 类加载器架构」(待更新)  



<br>

## 一，概述

虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。  
类型的加载、连接和初始化过程都是在程序运行期间完成的。  

* 缺点：  
    令类加载时稍微增加一些性能开销

* 优点：  
    为Java应用程序提供高度的灵活性。  
    Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

> 注意：  
> 第一，下文中直接对“类”的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明；  
> 第二，本章所提到的“Class文件”并非特指某个存在于具体磁盘中的文件，这里所说的“Class文件”应当是一串二进制的字节流，无论以何种形式存在都可以。

<br>

##  二，类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括（5个阶段）：  
① 加载（Loading）  
② 连接（Linking）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] 验证（Verification）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2] 准备（Preparation）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3] 解析（Resolution）  
③ 初始化（Initialization）  
④ 使用（Using）  
⑤ 卸载（Unloading）  

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9mszcu9esj30x00ba0wn.jpg)  

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地**开始**。而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

> 👆注意，这里说的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。比如，加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）就是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。


* Q：“什么情况下需要开始类加载过程的第一个阶段：加载？”  
A：“Java虚拟机规范中并没有进行强制约束，这点（开始加载的时机）可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有被Java程序“首次主动使用”的类才会对其进行“初始化”（而加载、验证、准备自然需要在此之前开始）  

### 2.1 Java程序对类的使用方式可以分为两种
##### ① 主动使用；
“主动使用”的7种情况：  
[1] 创建类的实例  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到 new 字节码指令（使用new关键字实例化对象的时候）  
[2] 访问某个类或接口的静态变量。或者对该静态变量赋值  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到 getstatic、putstatic 字节码指令（读取或设置一个类的静态字段的时候，被final修饰、已在编译期把结果放入常量池的静态字段除外）  
[3] 调用类的静态方法  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到 invokestatic 字节码指令（调用一个类的静态方法的时候）  
[4] 反射调用  
[5] 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。  
[6] Java虚拟机启动时被标明为启动类的类（包含main()方法的那个类）  
[7] 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

##### ② 被动使用
除了以上七种情况，其他的使用Java类的方式都被看作是对类的“被动使用”，都不会导致类的初始化。  

> 注意:  
> a）👆这里说的是“类的初始化”，但这并不意味着它不会去加载这个类，这个是不确定的（可能加载，也可能不加载）。能确定的是“被动使用”不会导致“初始化”的产生。  
> b）`调用 ClassLoader 类的 loadClass 方法加载一个类，并不是对类的主动调用，不会导致类的初始化。`

<br>

#### “主动使用” and “被动使用” 实例
* **① 通过子类引用父类的静态字段，不会导致子类初始化**  
![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n7xivgimj30r40qediu.jpg)

~~~
# 控制台
MyParent1 static block
hello world
~~~

👆“MyChild1”的“静态代码块”没有执行，说明“MyChild1”没有被初始化！！

**对于静态字段来说，只有直接定义了该字段的类才会被初始化。**

谁定义了这个“静态变量”，就表示对谁的“主动使用”

Q：我们怎么知道“MyChild1”没有被初始化，但是它有没有被“加载”了？？  
A：“MyChild1”类有被加载了。  
![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n7sx0az4j3236094ai8.jpg)  

<br>

* **② 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。**  

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n7wi3q8fj30r20smdjv.jpg)  

~~~
# 控制台
MyParent1 static block
MyChild1 static block
welcome
~~~

当一个类在初始化时，要求其父类全部都已经初始化完毕了。所以’Object’类会是第一个被初始化的。

> 注意：
> `这里是“父类全部”而不是“全部父类”。因为Java是单继承的，每个Java类只会有一个父类，而父类又可以有它的父类。。。而且每一个父类（即，这个类）只会被初始化一次。`

<br>

* **③ 通过数组定义的引用类，不会触发此类的初始化**

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n81j8h52j30zk0hadm7.jpg)  

~~~
# 控制台
<空>
~~~

运行之后发现没有输出“SuperClass init！”，说明并没有触发类com.bayern.shengsiyuan.jvm\_lecture.lesson1.linling.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为“[Lcom.bayern.shengsiyuan.jvm\_lecture.lesson1.linling.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机在**运行期**自动生成的（这有点像动态代理，动态代理的类就是虚拟机在运行期在执行过程当中帮助我们生成出来的）、直接继承于java.lang.Object的子类，创建动作由字节码指令anewarray触发。  
这个类代表了一个元素类型为com.bayern.shengsiyuan.jvm\_lecture.lesson1.linling.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动。（准确地说，越界检查不是封装在数组元素访问的类中，而是封装在数组访问的 iastore 字节码指令中）

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n84n21omj30zu0biana.jpg)    

👆可以看到SuperClass虽然没有被初始化，但是它被加载了。
而且，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。所以👆也看不到名为“[Lcom.bayern.shengsiyuan.jvm\_lecture.lesson1.linling.SuperClass”类的加载日志信息。

<br>

* **④ 『public static final int a = 1;』字面量常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化**  

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n888hofkj30r40iatau.jpg)  

~~~
# 控制台
hello world
~~~

final本身表示的是一个常量，它是不能被改变的。因此在编译阶段，这个常量就会被存入到，调用这个常量的那个方法所在的类的常量池当中。  

常量在编译阶段会存入到调用这个常量的方法所在类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量类的初始化。  

同时，通过“-XX:+TraceClassLoading”打印被类加载器加载的类信息，发现MyParent2类没有被加载！！  
> 注意，这里指的是将常量存放到了MyTest2类的常量池中，之后MyParent2与MyTest2就没有任何关系了。甚至，我们可以将MyParent2的’.class’文件删除。MyTest2依旧能够正常运行，结果不变。👈这里可以正常运行，是因为’MyParent2’类没有被加载，所以删除了其’.class’文件并没关系）  

> 根据字段类型的不同，字面量可以是CONSTANT\_Long\_info、CONSTANT\_Float\_info、CONSTANT\_Double\_info、CONSTANT\_Integer\_info、CONSTANT\_String\_info常量中的一种。  
> 详见：[深入解析“Java 字节码 ” 之 「类文件结构」](/programming_blog/2019/11/01/深入解析-Java-字节码-之-类文件结构/)

<br>

* **⑤ 『public static final int num = new Random().nextInt(25)』static final变量num因为在编译期的时候无法知道它的确切的值，所以只有等到运行的时候才能知道。这种情况下，会对定义常量的类进行初始化。**

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n8f4t717j30to0i4goa.jpg)  

~~~
# 控制台
MyClass2 static block
24
~~~

这里，MyClass2被初始化了，这是因为num的值在编译器是无法确定的，它不像上面的『public static final String str = “hello world”;』在编译期就已经能够确定这个str字段的值内容，并且str是类级别的属性（static），它被所有的实例对象共享，且该str字段是不可变的（final），从这两点（static final）编译器确定了str是一个“编译期可知的全局常量值”，因此就可以将其直接放到调用该字段的类的常量池中。而本例中，num的虽然也是“全局常量”，但是该常量的值在编译器是无法得知的，需要在运行时初始化MyClass2类时才能得到，所以这里会对MyClass2进行初始化。

<br>

* **⑥ 关于接口的初始化：**  
**a）当一个接口在初始化时，并不要求其父接口都完成了初始化。**  
**b）在初始化一个类时，并不会先初始化它所实现的接口。**  
**只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化。**  

~~~java
public class MyTest5 {
    public static void main(String[] args) {
        System.err.println(MyChild5.mic);
    }
}

interface MyParent5 {
    MyParent5.MyInnerClass pic = new MyParent5.MyInnerClass();
    int a = new Random().nextInt(56);
    class MyInnerClass {
        static {
            System.err.println("MyParent5.MyInnerClass static block");
        }
    }
}

class MyParent5Impl implements MyParent5 {
    public static int c = new Random().nextInt(16);
    static {
        System.out.println("MyParent5Impl static block");
    }
}
~~~

~~~
# 控制台
。。。。。。
[Loaded com.bayern.shengsiyuan.jvm_lecture.classload.lesson2.MyParent5 from file:/Users/hayashishaochie/Documents/IdeaWorkspace/shengshiyuanProject/jvm_lecture/build/classes/main/]
[Loaded com.bayern.shengsiyuan.jvm_lecture.classload.lesson2.MyParent5Impl from file:/Users/hayashishaochie/Documents/IdeaWorkspace/shengshiyuanProject/jvm_lecture/build/classes/main/]
。。。。。。
MyParent5Impl static block
~~~  

此时，通过追踪类加载信息打印日志可知’MyParent5’和‘MyParent5Impl’两个类都被加载了。但是，此时被初始化的只有’MyParent5Impl’类，而’MyParent5’仅是被加载了，并没有被初始化。

~~~
# 修改:
public class MyTest5 {
    public static void main(String[] args) {
        System.err.println(MyParent5Impl.pic);
    }
}
~~~

~~~
# 控制台
MyParent5.MyInnerClass static block
com.bayern.shengsiyuan.jvm_lecture.classload.lesson2.MyParent5$MyInnerClass@5e2de80c
~~~

此时，「MyParent5Impl.pic」实际上是对「MyParent5.pic」的直接引用。所以，会对 MyParent5 进行初始化，并不会对 MyParent5Impl 进行初始化。

<br>

## 二，类加载的过程

### 2.1 加载
* 发生的时机：  
Java虚拟机规范中并没有进行强制约束一个类需要在什么时候开始“加载”，但是Java严格规定了类被“初始化”阶段的情况，一个类一旦需要被“初始化”，它一定会先被“加载”。（“加载”、“验证”、“准备”需要在“初始化”之前开始）  
而一个不会被“初始化”的类也不能说明它没有被“加载”，这是不能确定的。

<br>

* 流程：  
在加载阶段，虚拟机需要完成以下3件事情：  
① 通过一个类的全限定名来获取定义此类的二进制字节流。  
注意，👆这里并没有指明“二进制字节流”要从一个’.class’文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。  
通常可以通过如下方式获取类的二进制字节流：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] 从本地系统中直接加载  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2] 从网络中获取，这种场景最典型的应用就是Applet。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3] 从zip，jar等归档文件中加载’.class’文件  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4] 从专有数据库中读取。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5] 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了  ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[6] 其他，。。。。。。  
② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。（在JDK 8中Class对象会被放在“元空间”）  
③ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。  
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。  
> 👆首先，方法区中存储了该类的信息，以特定的数据结构表示（数据存储格式由虚拟机实现自行定义）。而java.lang.Class类对象只是用于给外界访问该数据结构的一个入口。

	加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。
	
<br>	

* 关于“非数组类”的加载：  
相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。

* 关于“数组类”的加载：  
对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机在运行时直接创建的（‘数组’的父类是’Object’）。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建。

* 一个数组类（下面简称为C）创建过程就遵循以下规则：  
[1] 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。  
> 👆注意，这里说的是“加载”，并不是“初始化”  
Q：我们常说数组是由组件构成的。什么是组件了？  
A：组件就是多维数组去掉一维之后的类型。比如，一维数组“MyParent4[]”的组件就是“MyParent”类型，即“MyParent[]”由多个MyParent类型构成；而二维数组“MyParent[][]”的组件就是“MyParent[]”，即“MyParent[][]”由多个“MyParent[]”数组构成。  

	[2] 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。  
[3] 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。  

<br>

### 2.2 验证

* 目的：  
为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

	从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。

<br>

* 流程：  

验证阶段大致上会完成下面4个阶段的检验动作：  
① 文件格式验证  
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。  
目的：保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。

② 元数据验证  
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。  
目的：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。  

③ 字节码验证  
这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。  
目的：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。  

④ 符号引用验证  
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。  
目的：符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类。

对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

<br>

### 2.3 准备

* 目的：  
为类的静态变量分配内存，并将其初始化为默认值。

基本数据类型的零值：

| 数据类型 | 零值 |
|---|---|
| int | 0 |
| long | 0L |
| short | (short)0 |
| char | '\u0000' |
| byte | (byte)0 |
| boolean | false |
| float | 0.0f |
| double | 0.0d |
| reference | null |

但也存在着一些特殊情况：  
如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设类变量value的定义为：  

~~~
public static final int value = 123;
~~~

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

<br>

* 示例一：

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n96xyi59j30zk0ei40v.jpg)  

~~~
# 控制台
a : 0
str : hello world	
~~~

通过字节码文件查看：  

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n986haosj30mc05umxz.jpg)

分析：  
我们知道，在初始化阶段我们是根据静态字段（static）出现的顺序来依次进行该字段的初始化的。因此，由于『private static String str = "hello world”;』声明在了『private static TheSingleton theSingleton = new TheSingleton();』之后（即，在构造方法之后）。所以此时构造方法中打印的’str’是还未初始化为指定值的默认值（在准备阶段对其赋的默认值）；而在将『private static String str = "hello world”;』修改为『private static final String str = "hello world”;』后，此时‘str’字段属性表中存在ConstantValue属性，它会在准备期就将其赋了指定的值而非默认值，所以，此时打印的结果为’hello world’。

<br>

* 示例二：

~~~
public class MyTest6 {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println("counter1: " + Singleton.counter1);
        System.out.println("counter2: " + Singleton.counter2);
    }
}

class Singleton {
    public static int counter1;
    public static int counter2 = 0;
    private static Singleton singleton = new Singleton();
    private Singleton() {
        counter1++;
        counter2++;
    }
    public static Singleton getInstance() {
        return singleton;
    }
}
~~~

~~~
# 控制台
counter1: 1
counter2: 1
~~~

修改：

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n9a6q56wj30va0q60x4.jpg)  

~~~
# 控制台
counter1 : 1
counter2 : 0
~~~ 

原因：  
因为static是按申明顺序进行初始化的。因此由于『private static Singleton sigleton = new Singleton();』这句代码会先与『public static int counter2 = 0;』这句代码进行初始化，因为会先执行‘构造方法’。所以在执行完构造方法后’counter1’为’1’，’counter2’为’1’（注意，’counter1’和’counter2’是在准备阶段就分配好了内存，并赋了默认初始值）。接着！执行到『public static int counter2 = 0;』这句代码，又将‘counter2’重置赋值为了’0’。。。所以，就有了我们看到的结果了。  
同时，我们需要明白。在’构造方法’中使用的’counter1’是已经初始化好的（因为’counter1’的声明在『private static Singleton sigleton = new Singleton();』之前，因此初始化也在其之前），而’counter2’是还没初始化好但准备好的了（因为’counter2’的申明在『private static Singleton sigleton = new Singleton();』之后，因此初始化也在其之后）。

<br>

### 2.4 解析

* 目的：  
解析阶段是虚拟机在类的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程。

* 符号引用（Symbolic References）：  
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

* 直接引用（Direct References）：  
直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

*除invokedynamic指令以外：无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。（可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。）*

*对于invokedynamic指令（目的用于动态语言支持）：当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。（必须等到程序实际运行到这条指令的时候，解析动作才能进行。）*

<br>

### 2.5 初始化
为类的静态变量赋予正确的初始值

前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

初始化阶段是执行类构造器“<clint>()”方法的过程。  
① “＜clinit＞()”方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9n9dihyrvj30wq090dhj.jpg)  

② 『＜clinit＞()』方法与类的构造函数（或者说实例构造器『＜init＞()』方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的『＜clinit＞()』方法执行之前，父类的『＜clinit＞()』方法已经执行完毕。因此在虚拟机中第一个被执行的『＜clinit＞()』方法的类肯定是java.lang.Object。  
PS：关于『Unsafe#allocateInstance』方法，是不会执行任何的构造函数（『\<init>()』方法）。但是如果类未初始化的话，还是会初始化这个类的。  

③ 由于父类的『＜clinit＞()』方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。  

④ 『＜clinit＞()』方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成『＜clinit＞()』方法。  

⑤ 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成『＜clinit＞()』方法。但接口与类不同的是，执行接口的『＜clinit＞()』方法不需要先执行父接口的『＜clinit＞()』方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的『＜clinit＞()』方法。  
> 👆“接口的初始化”与“类的初始化”的区别：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。
（注意，这里是“父类全部”而不是“全部父类”。因为Java是单继承的，每个Java类只会有一个父类，而父类又可以有它的父类。。。而且每一个父类（即，这个类）只会被初始化一次。）
  
⑥ 虚拟机会保证一个类的『＜clinit＞()』方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的『＜clinit＞()』方法，其他线程都需要阻塞等待，直到活动线程执行『＜clinit＞()』方法完毕。如果在一个类的『＜clinit＞()』方法中有耗时很长的操作，就可能造成多个线程阻塞（其他线程虽然会被阻塞，但如果执行『＜clinit＞()』方法的那条线程退出『＜clinit＞()』方法后，其他线程唤醒之后不会再次进入『＜clinit＞()』方法。同一个类加载器下，一个类型只会初始化一次），在实际应用中这种阻塞往往是很隐蔽的。  






















